# Java核心技术

## 反射机制

Java 反射机制是在运行状态中，对于任意一个类，都能知道这个类的所有属性和方法。
对任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为Java语言的反射机制。

### 静态编译与动态编译

- 静态编译

  编译时确定类型，绑定对象

- 动态编译

  运行时确定对象，绑定对象

### 优缺点

- 优点

  运行期类型的判断，动态加载类，提高代码灵活度

- 缺点

  性能瓶颈：反射相当于一系列解释操作，通知 JVM 要做的事情，性能比直接的 Java 代码要慢得多
  安全问题：让我们可以动态操作改变类的属性同时也增加了类的安全隐患

### 应用场景

反射是框架设计的灵魂
比如 模块化开发，是通过反射去调用相应的字节码；动态代理设计模式；Spring/Hibernate等框架
在使用JDBC连接数据库时使用Class.forName()通过反射加载数据库的驱动程序
Spring框架的IOC(动态加载管理Bean)创建对象以及AOP(动态代理)功能都和反射有联系
动态配置实例的属性
......

## 异常

### 层次结构图

在 Java 中，所有异常都有一个共同点祖先 java.lang 包中的 Throwable 类
Error (错误)：程序无法处理的错误。表示运行程序中较严重的问题。大多数错误与代码编写者执行的操作无关，而表示代码运行时 JVM 出现的问题。这些错误表示故障发生于虚拟机自身，如Virtual MachineError。这些错误是不可查的，因为它们在应用程序的控制和处理能力之外，而且绝大多数程序运行时不允许出现的状况。
Exception (异常)：程序本身可以处理的异常。Exception 类有一个重要的子类 RuntimeException。RuntimeException 异常由 Java 虚拟机抛出，此外还有 NullPointerException 等等。

区别：异常能被程序本身处理，错误无法处理

- 异常层次结构图1
- 异常层次结构图2

### Throwable 类常用方法

public string getMessage():返回异常发生时的简要描述
public string toString():返回异常发生时的详细信息
public string getLocalizedMessage():返回异常对象的本地化信息。使用 Throwable 的子类覆盖这个方法，可以生成本地化信息。如果子类没有覆盖该方法，则该方法返回的信息与 getMessage（）返回的结果相同
public void printStackTrace():在控制台上打印 Throwable 对象封装的异常信息

### try-catch-finally

try 块：用于捕获异常，其后可接0个或多个 catch 块，若没有，则必须跟一个 finally 块
catch 块：用于处理 try 捕获到的异常
finally 块：无论是否捕获或处理异常，finally 块里的语句都会被执行。当在 try 块或 catch 块中遇到 return 语句时，finally 语句将在方法返回前被执行。比如：
public class Test {
    public static int f(int value) {
        try {
            return value * value;
        } finally {
            if (value == 2) {
                return 0;
            }
        }
    }
}

以下4种特殊情形，finally块不会被执行：
在 finally 语句块第一行发生了异常。因为在其他行，finally 块还是会得到执行。
在前面的代码中使用了 System. exit(int) 已退出程序。exit 时带参函数；若该语句在异常语句之后，finally 会执行
程序所在的线程死亡
关闭CPU

## 多线程

### 基本概念

- 程序

  程序是含有指令和数据的文件，被存储在磁盘或其他的数据存储设备中，即：程序是静态的代码

- 进程

  进程是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。
  系统运行一个程序即是一个进程从创建、运行到消亡的过程。

- 线程

  线程与进程相似，但线程是一个比进程更小的执行单位。
  一个进程在其执行过程中可以产生多个线程。与进程不同的是同类的多个线程共享同一块内存空间和一组系统资源，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多。
  正因如此，线程也被称作轻量级进程。

### 线程基本状态

线程创建之后它将处于 NEW(新建) 状态，调用 start() 方法后开始运行，线程这时候处于 READY(可运行)状态。
可运行状态的线程获得了 CPU 时间片 (timeslice) 后就处于 RUNNING (运行)状态

当线程执行 wait() 方法后，线程进入 WAITING (等待)状态。进入等待状态的线程需要依靠其他线程的通知才能够返回到运行状态，而 TIME_WAITING(超时等待) 状态相当于在等待状态的基础上增加了超时限制。
比如通过 sleep (long millis) 方法或 wait (long millis) 方法可以将 Java 线程置于 TIMED WAITING 状态。
当超时时间到达后， Java 线程将会返回到 RUNNABLE 状态。当线程调用同步方法时，在没有获取到锁的情况下，线程将会进入到 BLOCKED (阻塞) 状态。
线程在执行 Runable 的 run() 方法之后将会进入到 TERMINATED (终止) 状态。

- NEW

  初始状态，线程被构建，但是还没有调用 start() 方法

- RUNNABLE

  运行状态，Java 线程将操作系统中的就绪和运行两种状态笼统称为“运行中”

- BLOCKED

  阻塞状态，表示线程阻塞于锁

- WAITING

  等待状态，表示线程进入等待状态，进入该状态表示当前线程需要等待其他线程做出一些特定动作(通知或中断)

- TIME_WAITING

  超市等待状态，该状态不同于 WAITING，它是可以在指定的时间自行返回的

- TERMINATED

  终止状态，表示当前线程已经执行完毕

## 文件与I/O流

### 分类

- 流向

	- 输入流
	- 输出流

- 操作单元

	- 字节流
	- 字符流

- 角色

	- 节点流
	- 处理流

### 操作方式

### 操作对象

### 相关问题

- 有了字节流，为什么还要有字符流？

  该问题本质：不管文件读写还是网络发送接收，信息的最小单位都是字节，那为什么I/O 流操作要分为字节流操作和字符流操作呢？
  
  字符流是由 Java 虚拟机将字节转换得到的，问题就出在这个过程还算是耗时，并且，如果我们不知道编码类型就很容易出现乱码问题。
  所以，I/O 流就干脆提供一个直接操作字符的接口，方便我们平时对字符进行流操作。
  如果音频文件、图片等媒体文件用字节流比较好，如果涉及到字符的话则使用字符流比较好。

	- 字节流

	  Java中的字节流处理的最基本单位为单个字节。
	  它通常用来处理二进制数据。Java中最基本的两个字节流类是InputStream和OutputStream，它们分别代表了组基本的输入字节流和输出字节流。
	  InputStream类与OutputStream类均为抽象类，我们在实际使用中通常使用Java类库中提供的它们的一系列子类。

	- 字符流

	  Java中的字符流处理的最基本的单元是Unicode码元（大小2字节），它通常用来处理文本数据。所谓Unicode码元，也就是一个Unicode代码单元，范围是0x0000~0xFFFF。在以上范围内的每个数字都与一个字符相对应，Java中的String类型默认就把字符以Unicode规则编码而后存储在内存中。然而与存储在内存中不同，存储在磁盘上的数据通常有着各种各样的编码方式。使用不同的编码方式，相同的字符会有不同的二进制表示。实际上字符流是这样工作的：
	  输出字符流：把要写入文件的字符序列（实际上是Unicode码元序列）转为指定编码方式下的字节序列，然后再写入到文件中；
	  输入字符流：把要读取的字节序列按指定编码方式解码为相应字符序列（实际上是Unicode码元序列从）从而可以存在内存中。

- BIO NIO AIO

	- BIO

	  BIO (Blocking I/O) 同步阻塞 I/O 模式
	  数据的读取写入必须阻塞在一个线程内等待其完成。在活动连接数不是特别高（小于单机 1000）的情况下，这种模型是比较不错的，可以让每一个连接专注于自己的 I/O 并且编程模型简单，也不用过多考虑系统的过载、限流等问题。
	  
	  线程池本身就是一个天然的漏斗，可以缓冲一些系统处理不了的连接或请求。但是，当面对十万甚至百万级连接的时候，传统的 BIO 模型是无能为力的。
	  因此，我们需要一种更高效的 I/O 处理模型来应对更高的并发量。

	- NIO

	  NIO (Non-blocking/New I/O)
	  NIO 是一种同步非阻塞的 I/O 模型
	  在 Java 1.4 中引入了 NIO 框架，对应 java.nio 包，提供了 Channel , Selector，Buffer 等抽象。NIO 中的 N 可以理解为 Non-blocking，不单纯是 New。它支持面向缓冲的，基于通道的 I/O 操作方法。 NIO 提供了与传统 BIO 模型中的 Socket 和 ServerSocket 相对应的 SocketChannel 和 ServerSocketChannel 两种不同的套接字通道实现,两种通道都支持阻塞和非阻塞两种模式。阻塞模式使用就像传统中的支持一样，比较简单，但是性能和可靠性都不好；非阻塞模式正好与之相反。对于低负载、低并发的应用程序，可以使用同步阻塞 I/O 来提升开发速率和更好的维护性；对于高负载、高并发的（网络）应用，应使用 NIO 的非阻塞模式来开发

	- AIO

	  AIO (Asynchronous I/O)
	  AIO 也就是 NIO 2
	  在 Java 7 中引入了 NIO 的改进版 NIO 2,它是异步非阻塞的 IO 模型。异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。
	  AIO 是异步 IO 的缩写，虽然 NIO 在网络操作中，提供了非阻塞的方法，但是 NIO 的 IO 行为还是同步的。
	  对于 NIO 来说，我们的业务线程是在 IO 操作准备好时，得到通知，接着就由这个线程自行进行 IO 操作，IO 操作本身是同步的。查阅网上相关资料，我发现就目前来说 AIO 的应用还不是很广泛，Netty 之前也尝试使用过 AIO，不过又放弃了。

